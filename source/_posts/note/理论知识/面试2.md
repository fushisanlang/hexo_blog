---
title: 面试问题记录 二
tags:
  - 面试
categories:
  - note
abbrlink: 73eec1e7
date: 2022-01-17 00:00:00
---


### Linux运行级别

0. 关机模式
1. 单用户模式<==破解root密码
2. 无网络支持的多用户模式
3. 有网络支持的多用户模式（文本模式，工作中最常用的模式）
4. 保留，未使用
5. 有网络支持的X-windows支持多用户模式（桌面）
6. 重新引导系统，即重启
<!--more-->

### Linux中Buffer和Cache的区别
1. Cache
缓存区，是高速缓存，是位于CPU和主内存之间的容量较小但速度很快的存储器，因为CPU的速度远远高于主内存的速度，CPU从内存中读取数据需等待很长的时间，而  Cache保存着CPU刚用过的数据或循环使用的部分数据，这时从Cache中读取数据会更快，减少了CPU等待的时间，提高了系统的性能。
Cache并不是缓存文件的，而是缓存块的(块是I/O读写最小的单元)；Cache一般会用在I/O请求上，如果多个进程要访问某个文件，可以把此文件读入Cache中，这样下一个进程获取CPU控制权并访问此文件直接从Cache读取，提高系统性能。

2. Buffer
缓冲区，用于存储速度不同步的设备或优先级不同的设备之间传输数据；通过buffer可以减少进程间通信需要等待的时间，当存储速度快的设备与存储速度慢的设备进行通信时，存储慢的数据先把数据存放到buffer，达到一定程度存储快的设备再读取buffer的数据，在此期间存储快的设备CPU可以干其他的事情。
一般是用在写入磁盘的，例如：某个进程要求多个字段被读入，当所有要求的字段被读入之前已经读入的字段会先放到buffer中。

3. 区别
buffer和cache都是内存中的一块区域，当CPU需要写数据到磁盘时，由于磁盘速度比较慢，所以CPU先把数据存进buffer，然后CPU去执行其他任务，buffer中的数据会定期写入磁盘；当CPU需要从磁盘读入数据时，由于磁盘速度比较慢，可以把即将用到的数据提前存入cache，CPU直接从Cache中读取数据。

### 简述Linux中inode和block
inode节点是一个64字节长的表，表中包含了文件的相关信息，如：字节数、属主UserID、属组GroupID、读写执行权限、时间戳等。在inode节点表中最重要的内容是：磁盘地址表。
文件名存放在目录当中，但Linux系统内部不使用文件名，而是使用inode号码识别文件。对于系统来说文件名只是inode号码便于识别的别称。即Linux文件系统通过把inode和文件名进行关联来查找文件。当需要读取该文件时，文件系统在当前目录表中查找该文件名对应的项，由此得到该文件相对应的inode节点号，通过该inode节点的磁盘地址表把分散存放的文件物理块连接成文件的逻辑结构。
文件是存储在硬盘上的，硬盘的最小存储单位叫做扇区sector，每个扇区存储512字节。操作系统读取硬盘的时候，不会一个个扇区地读取，这样效率太低，而是一次性连续读取多个扇区，即一次性读取一个块block。这种由多个扇区组成的块，是文件存取的最小单位。块的大小，最常见的是4KB，即连续八个sector组成一个block。
即512字节组成一个扇区（sector），多个扇区组成一个块（block），常见的块单位4KB，即连续八个扇区组成一个block。
**一个文件必须占用一个inode，但至少占用一个block。**

### 简述Linux中软链接和硬链接的区别？
* 软链接
类似于Windows的快捷方式功能的文件，可以快速连接到目标文件或目录。即再创建一个独立的文件，而这个文件会让数据的读取指向它连接的那个文件的文件名。例如，文件A和文件B的inode号码虽然不一样，但是文件A的内容是文件B的路径。读取文件A时，系统会自动将访问者导向文件B。这时，文件A就称为文件B的软链接。因此，文件A依赖于文件B而存在，如果删除了文件B，打开文件A就会报错。


* 硬链接
通过文件系统的inode链接来产生的新的文件名，而不是产生新的文件，称为硬链接。一般情况下，每个inode号码对应一个文件名，但是Linux允许多个文件名指向同一个inode号码。意味着可以使用不同的文件名访问相同的内容。创建硬链接，源文件与目标文件的inode号码相同，都指向同一个inode。inode信息中的链接数这时就会增加1。
当一个文件拥有多个硬链接时，对文件内容修改，会影响到所有其他文件的内容；
删除一个文件名，不影响另一个文件名的访问，删除一个文件名，只会使得inode中的链接数减1。
* 区别
软链接是文件A指向文件B的文件名，而不是文件B的inode号码，文件B的inode链接数不会因此发生变化。
不能对目录做硬链接，但是通过mkdir命令创建一个新目录，通常其硬链接数应该有2个，因为常见的目录本身为1个硬链接，而目录下面的隐藏目录.（点号）是该目录的又一个硬链接，也算是1个连接数。

### 简述TCP三次握手，四次断开，及其优点和缺点，同时相对于UDP的差别？

* TCP
传输控制协议，即面向连接；
* UDP
用户数据报协议，无连接的，即发送数据之前不需要建立连接


* 三次握手

    * 第一次握手
    主机A向主机B发出一个含同步序列号的标志位的数据段给主机B ，向主机B请求建立连接。通过这个数据段，A向B声明通信请求，以及告知B可用某个序列号作为起始数据段进行响应；
    * 第二次握手
    主机B收到主机A的请求后，用一带有确认应答(ACK)和同步序列号(SYN)标志位的数据段响应A。通过此数据段，B向A声明已收到A的请求，A可以传输数据了，同时告知A可用某个序列号作为起始数据段进行响应；
    * 第三次握手
    主机A收到主机B的数据段后，再发送一个确认应答，确认已收到主机B 的数据段，之后开始正式实际传输数据。

    * ACK
    TCP报头的控制位之一，对数据进行确认。确认由目的端发出，来告知发送端这个序列号之前的数据段都收到了。比如，确认号为X，则表示前X-1个数据段都收到了。只有当ACK=1时，确认号才有效，当ACK=0时，确认号无效，此时会要求重传数据，保证数据的完整性。
    * SYN
    同步序列号，这个标志位只有在TCP建立连接时才会被置1，握手完成后SYN标志位被置0。


* 四次断开：
    * 当主机A完成数据传输后，将控制位FIN置1，提出停止TCP连接的请求；
    * 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭，将ACK置1；
    * 主机B再提出反方向的关闭请求，将FIN置1；
    * 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。


* TCP的优点
可靠，稳定。TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源。
* TCP的缺点：
慢、效率低、占用系统资源高、易被攻击：TCP在传递数据之前，要先建连接，需要消耗时间，而且在数据传递时，确认机制、重传机制、拥塞控制机制等都会消耗大量的时间，而且要在每台设备上维护所有的传输连接。同时，每个连接都会占用系统的CPU、内存等硬件资源。而且，因为TCP有确认机制、三次握手机制，这些也导致TCP容易被人利用，实现DOS、DDOS、CC等攻击。

    * DoS：拒绝服务（Denial of Servic），造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络带宽攻击和连通性攻击。
    * DDOS：分布式拒绝服务(DDoS:Distributed Denial of Service)，DDoS攻击指借助于客户/服务器技术，将多个计算机联合起来作为攻击平台，对一个或多个目标发动DDoS攻击，从而成倍地提高拒绝服务攻击的威力。

* UDP的优点
* 快、比TCP稍安全、没有TCP的握手、确认、窗口、重传、拥塞控制等机制，UDP是一个无状态的传输协议，所以它在传递数据时非常快。没有TCP的这些机制，UDP被攻击者利用的漏洞就要少一些。但UDP也是无法避免攻击的，比如：UDP Flood攻击。

    * UDP Flood攻击检测：短时间内向特定目标不断发送 UDP 报文，致使目标系统负担过重而不能处理合法的传输任务，就发生了 UDP Flood。启用 UDP Flood 攻击检测功能时，要求设置一个连接速率阈值，一旦发现保护主机响应的 UDP 连接速率超过该值，防火墙会输出发生 UDP Flood 攻击的告警日志，并且根据用户的配置可以阻止发往该主机的后续连接请求。


* UDP的缺点
不可靠、不稳定。因为UDP没有那些可靠的机制，在数据传递时，如果网络质量不好，就会很容易丢包。

* TCP应用场景
当对网络通讯质量有要求的时候，比如：整个数据要准确无误的传递给对方，要求可靠的应用，比如HTTP、HTTPS、FTP等传输文件的协议，POP、SMTP等邮件传输的协议。
* UDP应用场景
当对网络通讯质量要求不高的时候，要求网络通讯速度能尽量的快。比如QQ语音、QQ视频、TFTP 。

### TIME_WAIT状态
* 过程
  1. 被动关闭方发送FIN（第三次挥手），并等待主动关闭方返回ACK(第四次挥手)
  2. 若最终ACK丢失(第四次挥手失败)，被动关闭方将重新发送FIN(第三次挥手)，主动关闭方必须维护状态信息TIME_WAIT,保证自己可以接收，然后再重发最终ACK.不能让主动方发送完报文以后立马进入CLOSE状态
* 问题
  * 主动断开方处于TIME_WAIT状态时，源端口无法使用
  * 端口最大数是65535，因此如果频繁主动断开TCP连接，将很快耗尽端口号。一旦达到了上限，则新的请求就无法被处理，接着就是大量Too Many Open Files异常，然后tomcat、nginx、apache崩溃
* 解决TIME_WAIT问题
  * 解决TIME_WAIT大量出现，最核心的思想，就是打开系统的TIME_WAIT重用和快速回收
  * net.ipv4.tcp_tw_recycle = 1表示开启TCP连接中TIME_WAIT sockets的快速回收，默认为0,表示关闭
  * net.ipv4.tcp_tw_reuse = 1 表示开启重用。允许将TIME_WAIT sockets重新用于新的TCP连接，默认为0，表示关闭

### CLOSE_WAIT状态
* 出现原因
  * 对方关闭连接后，自身程序里没有检测 -（被动方的角度）
  * 本身忘了需要关闭连接，于是整个资源就一直被程序占用着。

* 解决方法
  * 关闭正在运行的程序
  * 尽快修改程序bug,然后测试提交到线上服务器